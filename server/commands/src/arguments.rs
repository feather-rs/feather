use crate::CommandCtx;

use feather_core::position;
//use feather_core::util::{Gamemode, Position};
use feather_core::util::Position;
//use feather_definitions::Item;
//use feather_server_types::{Game, Name, NetworkId, Player};
//use fecs::{component, Entity, IntoQuery, Read, World};
use lieutenant::{ArgumentKind, Input};
//use rand::Rng;
//use smallvec::SmallVec;
//use std::convert::Infallible;
use std::num::ParseFloatError;
use std::str::FromStr;
use thiserror::Error;

/**
 * This file contians the arguments used by the command parser
 * This list is generated by a utility found in
 * feather/command_generator. If you want to find info
 * on any one of the arguements check out this list.
 *
 * https://minecraft.gamepedia.com/Argument_types
 *
 * This file also contains some specialisations of the arguments listed
 * in the arugment type list link. There are as an example varius versions of
 * integers to specify what integers are valid in the command. In the future
 * we can use this to implement tab compleation.
 *
 */

/*
#[derive(Debug, Error)]
pub enum SelectorParseError {
    #[error("no player with name {0}")]
    PlayerNotFound(String),
}

/// Argument kind which supports entity selectors.
pub struct EntitySelector {
    /// Entities selected by the parameter.
    pub entities: SmallVec<[Entity; 1]>,
}

impl ArgumentKind<CommandCtx> for EntitySelector {
    type ParseError = SelectorParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");

        true
    }

    fn parse<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let head = input.advance_until(" ");

        // See https://minecraft.gamepedia.com/Commands#Target_selectors
        let entities = find_selected_entities(ctx, head)?;

        Ok(EntitySelector { entities })
    }
}

impl EntitySelector {
    /// Parses the returned entities for use in reporting success messages
    /// Either the name of the entity for one entity, or how many were affected for many entities.
    pub fn entities_to_string(&self, ctx: &CommandCtx, add_player: bool) -> String {
        if self.entities.is_empty() {
            "no entities".to_string()
        } else if self.entities.len() == 1 {
            if let Some(name) = ctx.world.try_get::<Name>(*self.entities.first().unwrap()) {
                if add_player {
                    if ctx
                        .world
                        .try_get::<Player>(*self.entities.first().unwrap())
                        .is_some()
                    {
                        format!("player {}", name.0)
                    } else {
                        format!("entity {}", name.0)
                    }
                } else {
                    name.0.to_string()
                }
            } else {
                "Server".to_string()
            }
        } else {
            // TODO: confirm this is correct behaviour for success messages involving many players
            let mut players = true;
            for entity in &self.entities {
                players &= ctx.world.try_get::<Player>(*entity).is_some();
            }
            if players {
                format!("{} players", self.entities.len())
            } else {
                format!("{} entities", self.entities.len())
            }
        }
    }
}

fn find_selected_entities(
    ctx: &CommandCtx,
    input: &str,
) -> Result<SmallVec<[Entity; 1]>, SelectorParseError> {
    use smallvec::smallvec;
    Ok(match input {
        "@p" => {
            // Nearest player
            let pos = ctx
                .world
                .try_get::<Position>(ctx.sender)
                .map(|r| *r)
                .unwrap_or(position!(0.0, 0.0, 0.0));

            nearest_player_to(&ctx.world, pos).into_iter().collect()
        }
        "@r" => {
            // Random player
            random_player(&ctx.game, &ctx.world).into_iter().collect()
        }
        "@a" => {
            // Every player
            <Read<Player>>::query()
                .iter_entities(ctx.world.inner())
                .map(|(e, _)| e)
                .collect()
        }
        "@e" => {
            // Every entity
            <Read<NetworkId>>::query()
                .iter_entities(ctx.world.inner())
                .map(|(e, _)| e)
                .collect()
        }
        "@s" => {
            // Command sender, if it was a player
            if ctx.world.has::<Player>(ctx.sender) {
                smallvec![ctx.sender]
            } else {
                SmallVec::new()
            }
        }
        player_name => smallvec![find_player_by_name(&ctx.world, player_name)
            .ok_or_else(|| SelectorParseError::PlayerNotFound(player_name.to_owned()))?],
    })
}

// TODO: eliminate linear searches.
// These search functions are incredibly naive.
fn find_player_by_name(world: &World, name: &str) -> Option<Entity> {
    <Read<Name>>::query()
        .iter_entities(world.inner())
        .find(|(_, n)| n.0 == name)
        .map(|(entity, _name)| entity)
}

fn nearest_player_to(world: &World, pos: Position) -> Option<Entity> {
    <Read<Position>>::query()
        .filter(component::<Player>())
        .iter_entities(world.inner())
        .min_by_key(|(_, p)| pos.distance_squared_to(**p).floor() as u64)
        .map(|(entity, _)| entity)
}

fn random_player(game: &Game, world: &World) -> Option<Entity> {
    let query = <Read<Player>>::query();

    let count = query.iter(world.inner()).count();

    let index = game.rng().gen_range(0, count);

    query
        .iter_entities(world.inner())
        .nth(index)
        .map(|(e, _)| e)
}

#[derive(Debug, Error)]
pub enum CoordinatesParseError {
    #[error("missing coordinate")]
    MissingCoordinate,
    #[error("failed to parse float: {0}")]
    ParseFloat(#[from] ParseFloatError),
}

/// Parses a position (<x> <y> <z>, but also with support for relative
/// positions as per https://minecraft.gamepedia.com/Commands#Tilde_and_caret_notation).
#[derive(Copy, Clone, Debug)]
pub struct Coordinates {
    pub x: Coordinate,
    pub y: Coordinate,
    pub z: Coordinate,
}

impl Coordinates {
    /// Converts these coordinates into a `Position`.
    ///
    /// The input `relative_to` is the position to interpret
    /// as the origin of relative coordinates. For example,
    /// this is the position of the target entity for the `/tp`
    /// command.
    pub fn into_position(self, relative_to: Position) -> Position {
        let direction = relative_to.direction();
        position!(
            Self::coordinate_into_absolute(self.x, relative_to.x, direction.x),
            Self::coordinate_into_absolute(self.y, relative_to.y, direction.y),
            Self::coordinate_into_absolute(self.z, relative_to.z, direction.z),
            relative_to.pitch,
            relative_to.yaw,
        )
    }

    fn coordinate_into_absolute(coord: Coordinate, relative_to: f64, facing_magnitude: f64) -> f64 {
        match coord {
            Coordinate::Absolute(coord) => coord,
            Coordinate::Relative(rel) => relative_to + rel,
            Coordinate::RelativeLook(rel) => relative_to + rel * facing_magnitude,
        }
    }
}

impl From<Position> for Coordinates {
    fn from(pos: Position) -> Self {
        Coordinates {
            x: Coordinate::Absolute(pos.x),
            y: Coordinate::Absolute(pos.y),
            z: Coordinate::Absolute(pos.z),
        }
    }
}

#[derive(Copy, Clone, Debug)]
pub enum Coordinate {
    /// Coordinates relative to some position. The origin
    /// is interpreted differently by different commands.
    ///
    /// For example, `/tp` interprets this as the coordinates
    /// relative to the initial position of the target entity.
    /// On the other hand, another command may use
    /// this as the coordinates relative to the sender's
    /// position.
    Relative(f64),
    /// Relative coordinates in the direction the player is looking.
    /// This is similar to `Relative`, but the axes are rotated
    /// to align with the entity's view direction.
    RelativeLook(f64),
    /// Absolute coordinates, in world space.
    Absolute(f64),
}

impl FromStr for Coordinate {
    type Err = CoordinatesParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some(first) = s.chars().next() {
            Ok(match first {
                '~' => {
                    let offset = if s.len() > 1 {
                        f64::from_str(&s[1..])?
                    } else {
                        0.0
                    };
                    Coordinate::Relative(offset)
                }
                '^' => {
                    let offset = if s.len() > 1 {
                        f64::from_str(&s[1..])?
                    } else {
                        0.0
                    };
                    Coordinate::RelativeLook(offset)
                }
                _ => Coordinate::Absolute(f64::from_str(s)?),
            })
        } else {
            Err(CoordinatesParseError::MissingCoordinate)
        }
    }
}

impl ArgumentKind<CommandCtx> for Coordinates {
    type ParseError = CoordinatesParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let x = input.advance_until(" ");
        let y = input.advance_until(" ");
        let z = input.advance_until(" ");

        let x = Coordinate::from_str(x)?;
        let y = Coordinate::from_str(y)?;
        let z = Coordinate::from_str(z)?;

        Ok(Coordinates { x, y, z })
    }
}

#[derive(Debug, Error)]
pub enum GamemodeParseError {
    #[error("invalid gamemode string {0}")]
    InvalidGamemode(String),
}

/// A parsed gamemode string ("survival", "creative", ...)
#[derive(Copy, Clone, Debug)]
pub struct ParsedGamemode(pub Gamemode);

impl ArgumentKind<CommandCtx> for ParsedGamemode {
    type ParseError = GamemodeParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        !input.advance_until(" ").is_empty()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let s = input.advance_until(" ");

        let gamemode = match s {
            "survival" => Gamemode::Survival,
            "creative" => Gamemode::Creative,
            "spectator" => Gamemode::Spectator,
            "adventure" => Gamemode::Adventure,
            s => return Err(GamemodeParseError::InvalidGamemode(s.to_owned())),
        };

        Ok(ParsedGamemode(gamemode))
    }
}

#[derive(Debug, Error)]
pub enum TextParseError {}

/// A multi-word argument (parses until the end of the command)
#[derive(Clone, Debug)]
pub struct TextArgument(pub String);

impl ArgumentKind<CommandCtx> for TextArgument {
    type ParseError = Infallible;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        !input.advance_to_end().is_empty()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_to_end();

        Ok(TextArgument(text.to_owned()))
    }
}

impl AsRef<str> for TextArgument {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}

#[derive(Debug, Error)]
pub enum ItemParseError {
    #[error("Unknown item {0}")]
    ItemDoesNotExist(String),
}

#[derive(Clone, Debug)]
pub struct ItemArgument(pub Item);

impl ArgumentKind<CommandCtx> for ItemArgument {
    type ParseError = ItemParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        !input.advance_until(" ").is_empty()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        let item = Item::from_identifier(text);
        match item {
            Some(s) => Ok(ItemArgument(s)),
            None => Err(ItemParseError::ItemDoesNotExist(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum I32ParseError {
    #[error("Invalid integer {0}")]
    Invalid(String),
}

#[derive(Clone, Debug)]
pub struct I32Argument(pub i32);

impl ArgumentKind<CommandCtx> for I32Argument {
    type ParseError = I32ParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        !input.advance_until(" ").is_empty()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        let number = text.parse::<i32>();
        match number {
            Ok(s) => Ok(I32Argument(s)),
            Err(_) => Err(I32ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum PositiveI32ParseError {
    #[error("Invalid integer {0}")]
    Invalid(String),
    #[error("Integer must not be less than 0, found {0}")]
    Negative(i32),
}

#[derive(Clone, Debug)]
pub struct PositiveI32Argument(pub i32);

impl ArgumentKind<CommandCtx> for PositiveI32Argument {
    type ParseError = PositiveI32ParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        !input.advance_until(" ").is_empty()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        let number = text.parse::<i32>();
        match number {
            Ok(integer) => {
                if integer >= 0 {
                    Ok(PositiveI32Argument(integer))
                } else {
                    Err(PositiveI32ParseError::Negative(integer))
                }
            }
            Err(_) => Err(PositiveI32ParseError::Invalid(text.to_owned())),
        }
    }
}
*/

#[derive(Debug, Error)]
pub enum BoolArgumentParseError {
    #[error("Invalid argument, not a bool true/false != {0}")]
    Invalid(String),
}

#[derive(Clone, Debug)]
pub struct BoolArgument(pub bool);

impl ArgumentKind<CommandCtx> for BoolArgument {
    type ParseError = BoolArgumentParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");

        match text {
            "true" => Ok(BoolArgument(true)),
            "false" => Ok(BoolArgument(false)),
            _ => Err(BoolArgumentParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum DoubleArgumentParseError {
    #[error("Invalid argument, not a double")]
    Invalid,
}

#[derive(Clone, Debug)]
pub struct DoubleArgument(pub f64);

impl ArgumentKind<CommandCtx> for DoubleArgument {
    type ParseError = DoubleArgumentParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match f64::from_str(text) {
            Ok(v) => Ok(DoubleArgument(v)),
            Err(_) => Err(Self::ParseError::Invalid),
        }
    }
}

#[derive(Debug, Error)]
pub enum FloatArgumentParseError {
    #[error("Invalid argument, not a float: {0}")]
    Invalid(String),
}

#[derive(Clone, Debug)]
pub struct FloatArgument(pub f32);

impl ArgumentKind<CommandCtx> for FloatArgument {
    type ParseError = FloatArgumentParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");

        match f32::from_str(text) {
            Ok(v) => Ok(FloatArgument(v)),
            Err(_) => Err(FloatArgumentParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum FloatArgumentBetween0And1ParseError {
    #[error("Invalid argument, not a float: {0}")]
    Invalid(String),

    #[error("Invalid range {0} not between 0 and 1")]
    InvalidRange(f32),
}

#[derive(Clone, Debug)]
pub struct FloatArgumentBetween0And1(pub f32);

impl ArgumentKind<CommandCtx> for FloatArgumentBetween0And1 {
    type ParseError = FloatArgumentBetween0And1ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match f32::from_str(text) {
            Ok(v) => {
                if 0.0 <= v && v <= 1.0 {
                    Ok(FloatArgumentBetween0And1(v))
                } else {
                    Err(FloatArgumentBetween0And1ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(FloatArgumentBetween0And1ParseError::Invalid(
                text.to_owned(),
            )),
        }
    }
}

#[derive(Debug, Error)]
pub enum FloatArgumentBetween0And2ParseError {
    #[error("Invalid argument, not a float: {0}")]
    Invalid(String),

    #[error("Invalid range {0} not between 0 and 2")]
    InvalidRange(f32),
}

#[derive(Clone, Debug)]
pub struct FloatArgumentBetween0And2(pub f32);

impl ArgumentKind<CommandCtx> for FloatArgumentBetween0And2 {
    type ParseError = FloatArgumentBetween0And2ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match f32::from_str(text) {
            Ok(v) => {
                if 0.0 <= v && v <= 2.0 {
                    Ok(FloatArgumentBetween0And2(v))
                } else {
                    Err(FloatArgumentBetween0And2ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(FloatArgumentBetween0And2ParseError::Invalid(
                text.to_owned(),
            )),
        }
    }
}

#[derive(Debug, Error)]
pub enum FloatArgumentPositiveParseError {
    #[error("Invalid argument, not a float: {0}")]
    Invalid(String),

    #[error("Invalid range {0} not a possitve number!")]
    InvalidRange(f32),
}

#[derive(Clone, Debug)]
pub struct FloatArgumentPositive(pub f32);

impl ArgumentKind<CommandCtx> for FloatArgumentPositive {
    type ParseError = FloatArgumentPositiveParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match f32::from_str(text) {
            Ok(v) => {
                if 0.0 <= v {
                    Ok(FloatArgumentPositive(v))
                } else {
                    Err(FloatArgumentPositiveParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(FloatArgumentPositiveParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum FloatArgumentGreaterThen1ParseError {
    #[error("Invalid argument, not a float: {0}")]
    Invalid(String),

    #[error("Invalid range {0} not a possitve number greather then 1!")]
    InvalidRange(f32),
}

#[derive(Clone, Debug)]
pub struct FloatArgumentGreaterThen1(pub f32);

impl ArgumentKind<CommandCtx> for FloatArgumentGreaterThen1 {
    type ParseError = FloatArgumentGreaterThen1ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match f32::from_str(text) {
            Ok(v) => {
                if 1.0 <= v {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),
}

#[derive(Clone, Debug)]
pub struct IntegerArgument(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgument {
    type ParseError = IntegerArgumentParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => Ok(Self(v)),
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentBetween0And1000000ParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),

    #[error("Invalid inetger, its not between 0 and 1000000")]
    InvalidRange(i64),
}

#[derive(Clone, Debug)]
pub struct IntegerArgumentBetween0And1000000(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgumentBetween0And1000000 {
    type ParseError = IntegerArgumentBetween0And1000000ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => {
                if 0 <= v && v <= 1000000 {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentBetween0And255ParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),

    #[error("Invalid inetger, its not between 0 and 255")]
    InvalidRange(i64),
}

#[derive(Clone, Debug)]
pub struct IntegerArgumentBetween0And255(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgumentBetween0And255 {
    type ParseError = IntegerArgumentBetween0And255ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => {
                if 0 <= v && v <= 255 {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentBetween0And65535ParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),

    #[error("Invalid inetger, its not between 0 and 65535")]
    InvalidRange(i64), //Could maybe be u16
}

#[derive(Clone, Debug)]
pub struct IntegerArgumentBetween0And65535(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgumentBetween0And65535 {
    type ParseError = IntegerArgumentBetween0And65535ParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => {
                if 0 <= v && v <= 65535 {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentPositiveParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),

    #[error("Invalid inetger, its not possitive.")]
    InvalidRange(i64), //Could maybe be u16
}

#[derive(Clone, Debug)]
pub struct IntegerArgumentPositive(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgumentPositive {
    type ParseError = IntegerArgumentPositiveParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => {
                if 0 <= v {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentBetween1And1000000ParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),

    #[error("Invalid inetger, its not between 1 and 1000000.")]
    InvalidRange(i64),
}

#[derive(Clone, Debug)]
pub struct IntegerArgumentBetween1And1000000(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgumentBetween1And1000000 {
    type ParseError = IntegerArgumentBetween1And1000000ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => {
                if 1 <= v && v <= 1000000 {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentBetween1And64ParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),

    #[error("Invalid inetger, its not between 1 and 64.")]
    InvalidRange(i64), //could be a smaller integer type
}

#[derive(Clone, Debug)]
pub struct IntegerArgumentBetween1And64(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgumentBetween1And64 {
    type ParseError = IntegerArgumentBetween1And64ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => {
                if 1 <= v && v <= 64 {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum IntegerArgumentGreaterThen1ParseError {
    #[error("Invalid argument, not a integer: {0}")]
    Invalid(String),

    #[error("Invalid inetger, its not greater or equal to 1")]
    InvalidRange(i64), //could be a smaller integer type
}

#[derive(Clone, Debug)]
pub struct IntegerArgumentGreaterThen1(pub i64);

impl ArgumentKind<CommandCtx> for IntegerArgumentGreaterThen1 {
    type ParseError = IntegerArgumentGreaterThen1ParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        match i64::from_str(text) {
            Ok(v) => {
                if 1 <= v {
                    Ok(Self(v))
                } else {
                    Err(Self::ParseError::InvalidRange(v))
                }
            }
            Err(_) => Err(Self::ParseError::Invalid(text.to_owned())),
        }
    }
}

#[derive(Debug, Error)]
pub enum StringArgumentGreedyParseError {}

#[derive(Clone, Debug)]
pub struct StringArgumentGreedy(pub String);

impl ArgumentKind<CommandCtx> for StringArgumentGreedy {
    type ParseError = StringArgumentGreedyParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_to_end();
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_to_end();
        Ok(StringArgumentGreedy(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum StringArgumentPhraseParseError {
    #[error("String starting with a double quote was not closed.")]
    Invalid(String),
}

/*
    This argument is for cases were minecraft commands either expect a single word lik 'hello',
    but it can also accept a quoted string "hello world". I beleve we should accept 'a"hello"a',
    and 'a"hello' as valid arguments.
*/

#[derive(Clone, Debug)]
pub struct StringArgumentPhrase(pub String);

impl ArgumentKind<CommandCtx> for StringArgumentPhrase {
    type ParseError = StringArgumentPhraseParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        let mut text = input.advance_until(" ");
        //TODO this is not correct
        if text.starts_with('\"') {
            while !text.ends_with('\"') && !input.is_empty() {
                text = input.advance_until(" ");
            }

            if !text.ends_with('\"') {
                return false;
            }
        }

        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let mut text = input.advance_until(" ");
        let mut res = text.to_owned();
        //TODO this is not correct
        if text.starts_with('\"') {
            while !text.ends_with('\"') && !input.is_empty() {
                text = input.advance_until(" ");
                res += text;
            }

            if !text.ends_with('\"') {
                return Err(Self::ParseError::Invalid(res));
            }
        }

        //TODO
        Ok(StringArgumentPhrase(res))
    }
}

#[derive(Debug, Error)]
pub enum StringArgumentWordParseError {}

#[derive(Clone, Debug)]
pub struct StringArgumentWord(pub String);

impl ArgumentKind<CommandCtx> for StringArgumentWord {
    type ParseError = StringArgumentWordParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        //TODO we should figure out how words starting with quotes (" or ') should
        //be parsed.
        !input.is_empty()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        Ok(StringArgumentWord(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum CoordinatesParseError {
    #[error("missing coordinate")]
    MissingCoordinate,
    #[error("failed to parse float: {0}")]
    ParseFloat(#[from] ParseFloatError),
}

/// Parses a position (<x> <y> <z>, but also with support for relative
/// positions as per https://minecraft.gamepedia.com/Commands#Tilde_and_caret_notation).
/// This is a rename of what the command list calls minecraft:block_pos
#[derive(Copy, Clone, Debug)]
pub struct Coordinates {
    pub x: Coordinate,
    pub y: Coordinate,
    pub z: Coordinate,
}

impl Coordinates {
    /// Converts these coordinates into a `Position`.
    ///
    /// The input `relative_to` is the position to interpret
    /// as the origin of relative coordinates. For example,
    /// this is the position of the target entity for the `/tp`
    /// command.
    pub fn _into_position(self, relative_to: Position) -> Position {
        let direction = relative_to.direction();
        position!(
            Self::_coordinate_into_absolute(self.x, relative_to.x, direction.x),
            Self::_coordinate_into_absolute(self.y, relative_to.y, direction.y),
            Self::_coordinate_into_absolute(self.z, relative_to.z, direction.z),
            relative_to.pitch,
            relative_to.yaw,
        )
    }

    fn _coordinate_into_absolute(
        coord: Coordinate,
        relative_to: f64,
        facing_magnitude: f64,
    ) -> f64 {
        match coord {
            Coordinate::Absolute(coord) => coord,
            Coordinate::Relative(rel) => relative_to + rel,
            Coordinate::RelativeLook(rel) => relative_to + rel * facing_magnitude,
        }
    }
}

impl From<Position> for Coordinates {
    fn from(pos: Position) -> Self {
        Coordinates {
            x: Coordinate::Absolute(pos.x),
            y: Coordinate::Absolute(pos.y),
            z: Coordinate::Absolute(pos.z),
        }
    }
}

#[derive(Copy, Clone, Debug)]
pub enum Coordinate {
    /// Coordinates relative to some position. The origin
    /// is interpreted differently by different commands.
    ///
    /// For example, `/tp` interprets this as the coordinates
    /// relative to the initial position of the target entity.
    /// On the other hand, another command may use
    /// this as the coordinates relative to the sender's
    /// position.
    Relative(f64),
    /// Relative coordinates in the direction the player is looking.
    /// This is similar to `Relative`, but the axes are rotated
    /// to align with the entity's view direction.
    RelativeLook(f64),
    /// Absolute coordinates, in world space.
    Absolute(f64),
}

impl FromStr for Coordinate {
    type Err = CoordinatesParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some(first) = s.chars().next() {
            Ok(match first {
                '~' => {
                    let offset = if s.len() > 1 {
                        f64::from_str(&s[1..])?
                    } else {
                        0.0
                    };
                    Coordinate::Relative(offset)
                }
                '^' => {
                    let offset = if s.len() > 1 {
                        f64::from_str(&s[1..])?
                    } else {
                        0.0
                    };
                    Coordinate::RelativeLook(offset)
                }
                _ => Coordinate::Absolute(f64::from_str(s)?),
            })
        } else {
            Err(CoordinatesParseError::MissingCoordinate)
        }
    }
}

impl ArgumentKind<CommandCtx> for Coordinates {
    type ParseError = CoordinatesParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let x = input.advance_until(" ");
        let y = input.advance_until(" ");
        let z = input.advance_until(" ");

        let x = Coordinate::from_str(x)?;
        let y = Coordinate::from_str(y)?;
        let z = Coordinate::from_str(z)?;

        Ok(Coordinates { x, y, z })
    }
}

#[derive(Debug, Error)]
pub enum BlockPredicateParseError {}

#[derive(Clone, Debug)]
pub struct BlockPredicate(pub String);
/*
This is used in execute if/unless stamtemtns were we check for some predicate
of the block at a possition.

https://minecraft.gamepedia.com/Predicate

Since 1.13 the block states are specified like this:
    lever[face=floor]Â or minecraft:lever[face=floor],

nbt data can also be querried by adding {foo:nbt} at the end. This means that we are
suposed to be able to parse 'minecraft:lever[face=floor]{foo:nbt}' as a valid block preicate.

It is also suposed to be able to parse Block tags, https://minecraft.gamepedia.com/Tag#Block_tags
*/
impl ArgumentKind<CommandCtx> for BlockPredicate {
    type ParseError = BlockPredicateParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(BlockPredicate(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum BlockStateParseError {}

#[derive(Clone, Debug)]
pub struct BlockState(pub String);
/**
 * It seems that block predicate and block state are close to identical, just that BlockState does
 * not accept Block Tags. https://minecraft.gamepedia.com/Tag#Block_tags
 */

impl ArgumentKind<CommandCtx> for BlockState {
    type ParseError = BlockStateParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(BlockState(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ColorParseError {
    #[error("Not a valid Color")]
    NotValid,
}

//Encodes chat colors.
#[derive(Clone, Debug)]
pub enum Color {
    Aqua,
    Black,
    Blue,
    DarkAqua,
    DarkBlue,
    DarkGray,
    DarkGreen,
    DarkPurple,
    DarkRed,
    Gold,
    Gray,
    Green,
    LightPurple,
    Red,
    Reset, //Default no colour
    Yellow,
    White,
}

impl FromStr for Color {
    type Err = ColorParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "aqua" => Ok(Color::Aqua),
            "black" => Ok(Color::Black),
            "blue" => Ok(Color::Blue),
            "dark_aqua" => Ok(Color::DarkAqua),
            "dark_blue" => Ok(Color::DarkBlue),
            "dark_gray" => Ok(Color::DarkGray),
            "dark_green" => Ok(Color::DarkGreen),
            "dark_purple" => Ok(Color::DarkPurple),
            "dark_red" => Ok(Color::DarkRed),
            "gold" => Ok(Color::Gold),
            "gray" => Ok(Color::Gray),
            "green" => Ok(Color::Green),
            "light_purple" => Ok(Color::LightPurple),
            "red" => Ok(Color::Red),
            "reset" => Ok(Color::Reset), //Default (no colour)
            "yellow" => Ok(Color::Yellow),
            "white" => Ok(Color::White),
            _ => Err(Self::Err::NotValid),
        }
    }
}

impl ArgumentKind<CommandCtx> for Color {
    type ParseError = ColorParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        let text = input.advance_until(" ");
        Color::from_str(text).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        Color::from_str(text)
    }
}

#[derive(Debug, Error)]
pub enum ColumnPosParseError {
    #[error("failed coordinates.")]
    ParseError,
}

#[derive(Clone, Debug)]
pub struct ColumnPos(i64, i64);

impl ArgumentKind<CommandCtx> for ColumnPos {
    type ParseError = ColumnPosParseError;

    fn satisfies<'a>(ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        Self::parse(ctx, input).is_ok()
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let fst = input.advance_until(" ");
        let snd = input.advance_until(" ");

        let x = i64::from_str(fst);
        let y = i64::from_str(snd);

        match (x, y) {
            (Ok(x), Ok(y)) => Ok(ColumnPos(x, y)),
            _ => Err(Self::ParseError::ParseError),
        }
    }
}

#[derive(Debug, Error)]
pub enum ComponentParseError {
    #[error("Does not start with a open tag!")]
    DoesNotStartWithOpenTag,

    #[error("Does not have a closing tag!")]
    HasNoClosingTag,
}

#[derive(Clone, Debug)]
pub struct Component(pub String);
/*
The component is Raw JSON text format.
https://minecraft.gamepedia.com/Raw_JSON_text_format
*/

impl ArgumentKind<CommandCtx> for Component {
    type ParseError = ComponentParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        let mut text = input.advance_until(" ");

        if !text.starts_with('{') {
            return false;
        }

        while !text.ends_with('}') {
            if input.is_empty() {
                return false;
            }
            text = input.advance_until("}");
        }

        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let mut text = input.advance_until(" ");
        let mut res = text.to_owned();

        if !text.starts_with('{') {
            return Err(Self::ParseError::DoesNotStartWithOpenTag);
        }

        while !text.ends_with('}') {
            if input.is_empty() {
                return Err(Self::ParseError::HasNoClosingTag);
            }
            text = input.advance_until(" ");
            res += text;
        }

        Ok(Component(res))
    }
}

/*
This is used for encoding dimension names, like
minecraft:overworld, minecraft:the_nether, but its
not used in any commands atm so its commented out.
The file impls.rs does not have all vanilla commands,
so it might be needed in the future, or some of the cyclic
commands take a dimention as a argument.


#[derive(Debug, Error)]
pub enum DimensionParseError {}

#[derive(Clone, Debug)]
pub struct Dimension(pub String);

impl ArgumentKind<CommandCtx> for Dimension {
    type ParseError = DimensionParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Dimension(text.to_owned()))
    }
}

*/

#[derive(Debug, Error)]
pub enum EntityAnchorParseError {
    #[error("Not 'eyes' or 'feet'")]
    ParseError,
}

#[derive(Clone, Debug)]
pub enum EntityAnchor {
    /*
    This is used in teleport command, to say if command
    is relative to head or feet.
    */
    Eyes,
    Feet,
}

impl ArgumentKind<CommandCtx> for EntityAnchor {
    type ParseError = EntityAnchorParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        let text = input.advance_until(" ");
        text == "eyes" || text == "feet"
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        if text == "eyes" {
            Ok(EntityAnchor::Eyes)
        } else if text == "feet" {
            Ok(EntityAnchor::Feet)
        } else {
            Err(Self::ParseError::ParseError)
        }
    }
}

#[derive(Debug, Error)]
pub enum EntitySummonParseError {}

#[derive(Clone, Debug)]
pub struct EntitySummon(pub String);
/**
 * This argument is used by the summon command, and
 * encodes the entety that is suposed to be summoned.
 * scifi6546 has made a pull request that solves this.
 * His solution should be merged here.
 */

impl ArgumentKind<CommandCtx> for EntitySummon {
    type ParseError = EntitySummonParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(EntitySummon(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum MultipleEntitiesParseError {}

#[derive(Clone, Debug)]
pub struct MultipleEntities(pub String);
/*
    Can be a player name, target selector or UUID.
    The target selector can select multiple enteties,
    that dont have to be players.
*/

impl ArgumentKind<CommandCtx> for MultipleEntities {
    type ParseError = MultipleEntitiesParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(MultipleEntities(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum MultiplePlayersParseError {}

#[derive(Clone, Debug)]
pub struct MultiplePlayers(pub String);

impl ArgumentKind<CommandCtx> for MultiplePlayers {
    type ParseError = MultiplePlayersParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(MultiplePlayers(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum SingleEntitiesParseError {}

#[derive(Clone, Debug)]
pub struct SingleEntities(pub String);

impl ArgumentKind<CommandCtx> for SingleEntities {
    type ParseError = SingleEntitiesParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(SingleEntities(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum SinglePlayerParseError {}

#[derive(Clone, Debug)]
pub struct SinglePlayer(pub String);
//Name of player or target selector

impl ArgumentKind<CommandCtx> for SinglePlayer {
    type ParseError = SinglePlayerParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(SinglePlayer(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum MinecraftFunctionParseError {}

#[derive(Clone, Debug)]
pub struct MinecraftFunction(pub String);
/*
This is the name of a function stored localy on the server.
See: https://www.digminecraft.com/game_commands/function_command.php

As far as i can see the name cant contain a space, so the current implementation
is working, but someone should confirm.
*/

impl ArgumentKind<CommandCtx> for MinecraftFunction {
    type ParseError = MinecraftFunctionParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO add code to check if command is present.
        // remember to add permissions for allowing people to do
        // this.
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(MinecraftFunction(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum GameProfileParseError {}

#[derive(Clone, Debug)]
pub struct GameProfile(pub String);
/*
Must be a player name, a target selector or a UUID.
Does not have to be online or even real.

Represents a collection of game profiles (player profiles).
It is backed by a target selector that only selects players.
Official examples

*/

impl ArgumentKind<CommandCtx> for GameProfile {
    type ParseError = GameProfileParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(GameProfile(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum IntRangeParseError {}

#[derive(Clone, Debug)]
pub struct IntRange {
    from: i64,
    to: i64,
}
/*
0: Exact match of 0.
..0: Less than or equal to 0.
0..: More than or equal to 0.
0..1
*/

impl ArgumentKind<CommandCtx> for IntRange {
    type ParseError = IntRangeParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        input.advance_until(" ");

        //TODO
        Ok(IntRange { from: 0, to: 0 })
    }
}

#[derive(Debug, Error)]
pub enum EnchantmentParseError {}

#[derive(Clone, Debug)]
pub struct Enchantment(pub String);

impl ArgumentKind<CommandCtx> for Enchantment {
    type ParseError = EnchantmentParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //This is suposed to parse a valid namespace that is a enchantment.
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Enchantment(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum PredicateParseError {}

#[derive(Clone, Debug)]
pub struct Predicate(pub String);
/*
This is a rename of what minecraft calls a item_predicate.
*/

impl ArgumentKind<CommandCtx> for Predicate {
    type ParseError = PredicateParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Predicate(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ItemSlotParseError {}

#[derive(Clone, Debug)]
pub struct ItemSlot(pub String);

impl ArgumentKind<CommandCtx> for ItemSlot {
    type ParseError = ItemSlotParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(ItemSlot(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ItemStackParseError {}

#[derive(Clone, Debug)]
pub struct ItemStack(pub String);

impl ArgumentKind<CommandCtx> for ItemStack {
    type ParseError = ItemStackParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(ItemStack(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum MessageParseError {}

#[derive(Clone, Debug)]
pub struct Message(pub String);
/*
A message is given in minecrafts raw-json format, that encodes rich text features.

*/

impl ArgumentKind<CommandCtx> for Message {
    type ParseError = MessageParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        let was_empty = input.is_empty();
        input.advance_until(" ");
        was_empty
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO convert all target selectors with the name of the entety.
        Ok(Message(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum MobEffectParseError {}

#[derive(Clone, Debug)]
pub struct MobEffect(pub String);

impl ArgumentKind<CommandCtx> for MobEffect {
    type ParseError = MobEffectParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(MobEffect(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum NbtCommandTagParseError {}

#[derive(Clone, Debug)]
pub struct NbtCommandTag(pub String);

impl ArgumentKind<CommandCtx> for NbtCommandTag {
    type ParseError = NbtCommandTagParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(NbtCommandTag(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum NbtPathParseError {}

#[derive(Clone, Debug)]
pub struct NbtPath(pub String);

impl ArgumentKind<CommandCtx> for NbtPath {
    type ParseError = NbtPathParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(NbtPath(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum NbtTagParseError {}

#[derive(Clone, Debug)]
pub struct NbtTag(pub String);

impl ArgumentKind<CommandCtx> for NbtTag {
    type ParseError = NbtTagParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(NbtTag(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ObjectiveParseError {}

#[derive(Clone, Debug)]
pub struct Objective(pub String);

impl ArgumentKind<CommandCtx> for Objective {
    type ParseError = ObjectiveParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Objective(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ObjectiveCriteriaParseError {}

#[derive(Clone, Debug)]
pub struct ObjectiveCriteria(pub String);

impl ArgumentKind<CommandCtx> for ObjectiveCriteria {
    type ParseError = ObjectiveCriteriaParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(ObjectiveCriteria(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum OperationParseError {}

#[derive(Clone, Debug)]
pub struct Operation(pub String);

impl ArgumentKind<CommandCtx> for Operation {
    type ParseError = OperationParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Operation(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ParticleParseError {}

#[derive(Clone, Debug)]
pub struct Particle(pub String);

impl ArgumentKind<CommandCtx> for Particle {
    type ParseError = ParticleParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Particle(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ResourceLocationParseError {}

#[derive(Clone, Debug)]
pub struct ResourceLocation(pub String);

impl ArgumentKind<CommandCtx> for ResourceLocation {
    type ParseError = ResourceLocationParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(ResourceLocation(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum RotationParseError {}

#[derive(Clone, Debug)]
pub struct Rotation(pub String);

impl ArgumentKind<CommandCtx> for Rotation {
    type ParseError = RotationParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Rotation(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum MultipleScoreHoldersParseError {}

#[derive(Clone, Debug)]
pub struct MultipleScoreHolders(pub String);

impl ArgumentKind<CommandCtx> for MultipleScoreHolders {
    type ParseError = MultipleScoreHoldersParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(MultipleScoreHolders(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum SingleScoreHolderParseError {}

#[derive(Clone, Debug)]
pub struct SingleScoreHolder(pub String);

impl ArgumentKind<CommandCtx> for SingleScoreHolder {
    type ParseError = SingleScoreHolderParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(SingleScoreHolder(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum ScoreboardSlotParseError {}

#[derive(Clone, Debug)]
pub struct ScoreboardSlot(pub String);

impl ArgumentKind<CommandCtx> for ScoreboardSlot {
    type ParseError = ScoreboardSlotParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(ScoreboardSlot(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum SwizzleParseError {}

#[derive(Clone, Debug)]
pub struct Swizzle(pub String);

impl ArgumentKind<CommandCtx> for Swizzle {
    type ParseError = SwizzleParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Swizzle(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum TeamParseError {}

#[derive(Clone, Debug)]
pub struct Team(pub String);

impl ArgumentKind<CommandCtx> for Team {
    type ParseError = TeamParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Team(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum TimeParseError {}

#[derive(Clone, Debug)]
pub struct Time(pub String);

impl ArgumentKind<CommandCtx> for Time {
    type ParseError = TimeParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Time(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum UuidParseError {}

#[derive(Clone, Debug)]
pub struct Uuid(pub String);

impl ArgumentKind<CommandCtx> for Uuid {
    type ParseError = UuidParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Uuid(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum Vec2ParseError {}

#[derive(Clone, Debug)]
pub struct Vec2(pub String);

impl ArgumentKind<CommandCtx> for Vec2 {
    type ParseError = Vec2ParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Vec2(text.to_owned()))
    }
}

#[derive(Debug, Error)]
pub enum Vec3ParseError {}

#[derive(Clone, Debug)]
pub struct Vec3(pub String);

impl ArgumentKind<CommandCtx> for Vec3 {
    type ParseError = Vec3ParseError;

    fn satisfies<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> bool {
        input.advance_until(" ");
        //TODO
        true
    }

    fn parse<'a>(_ctx: &CommandCtx, input: &mut Input<'a>) -> Result<Self, Self::ParseError> {
        let text = input.advance_until(" ");
        //TODO
        Ok(Vec3(text.to_owned()))
    }
}
